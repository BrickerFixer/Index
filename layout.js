document.addEventListener('DOMContentLoaded', function() {
    // Elements
    const editToggleBtn = document.getElementById('edit-toggle');
    const toolbox = document.getElementById('toolbox');
    const grid = document.getElementById('grid');
    
    // Variables
    let isEditMode = false;
    let selectedSpecial = null;
    let draggedWidget = null;
    let draggedCell = null;
    let targetCell = null;
    
    // Initialize the grid
    createGrid();
    
    // Toggle edit mode
    editToggleBtn.addEventListener('click', function() {
      isEditMode = !isEditMode;
      
      if (isEditMode) {
        grid.classList.remove('view-mode');
        grid.classList.add('edit-mode');
        toolbox.classList.add('visible');
        this.classList.add('header__action_pressed_yes');
      } else {
        grid.classList.remove('edit-mode');
        grid.classList.add('view-mode');
        toolbox.classList.remove('visible');
        this.classList.remove('header__action_pressed_yes');
      }
    });
    
    // Create the grid cells
    function createGrid() {
      grid.innerHTML = '';
      for (let row = 0; row < 6; row++) {
        for (let col = 0; col < 6; col++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.dataset.row = row;
          cell.dataset.col = col;
          
          cell.addEventListener('click', function() {
            if (!isEditMode) return;
            
            if (selectedSpecial) {
              placeWidgetByType(this, selectedSpecial, {});
            }
          });
          
          // For drag and drop functionality
          cell.addEventListener('dragover', function(e) {
            if (!isEditMode) return;
            e.preventDefault();
            targetCell = this;
          });
          
          grid.appendChild(cell);
        }
      }
    }
    
    // --- Widget Registry ---
    const WidgetRegistry = {
      types: {},
      register(type, config) {
        this.types[type] = config;
      },
      get(type) {
        return this.types[type];
      },
      getAll() {
        return Object.entries(this.types).map(([type, config]) => ({ type, ...config }));
      }
    };

    // --- Dynamic Widget Loader ---
    async function loadWidgets() {
      // Scan for widget files using a manifest generated by the server
      let widgetFiles = [];
      try {
        const resp = await fetch('client/js/bento-widgets/manifest.json');
        widgetFiles = await resp.json();
      } catch (e) {
        console.error('Failed to load widget manifest:', e);
        return;
      }
      for (const file of widgetFiles) {
        const modulePath = `./client/js/bento-widgets/${file}`;
        try {
          const widgetDef = (await import(modulePath)).default;
          if (widgetDef && widgetDef.type) {
            WidgetRegistry.register(widgetDef.type, widgetDef);
          }
        } catch (e) {
          console.error('Failed to load widget module:', modulePath, e);
        }
      }
      renderToolbox();
      restoreLayout();
    }

    // --- Layout Persistence ---
    function saveLayout() {
      const layout = [];
      document.querySelectorAll('.cell.widget-cell').forEach(cell => {
        const widget = cell.querySelector('.widget');
        if (!widget) return;
        layout.push({
          type: widget.dataset.type,
          row: parseInt(cell.dataset.row),
          col: parseInt(cell.dataset.col),
          colSpan: parseInt(widget.dataset.colSpan),
          rowSpan: parseInt(widget.dataset.rowSpan)
        });
      });
      localStorage.setItem('bentoGridLayout', JSON.stringify(layout));
    }

    function restoreLayout() {
      const layout = JSON.parse(localStorage.getItem('bentoGridLayout') || '[]');
      if (!layout.length) return;
      // Clear grid
      document.querySelectorAll('.cell.widget-cell').forEach(cell => {
        removeWidget(cell);
      });
      // Place widgets
      for (const item of layout) {
        const cell = document.querySelector(`.cell[data-row="${item.row}"][data-col="${item.col}"]`);
        if (cell) {
          placeWidgetByType(cell, item.type, {});
        }
      }
    }

    // --- Toolbox UI Generation ---
    function renderToolbox() {
      const blocksSection = document.querySelector('.blocks-section');
      blocksSection.innerHTML = '';
      WidgetRegistry.getAll().forEach(widget => {
        const btn = document.createElement('div');
        btn.className = 'special-block';
        btn.setAttribute('data-type', widget.type);
        btn.innerText = widget.label;
        btn.addEventListener('click', function() {
          if (!isEditMode) return;
          document.querySelectorAll('.special-block').forEach(b => b.style.boxShadow = 'none');
          btn.style.boxShadow = '0 0 0 3px #333';
          selectedSpecial = widget.type;
        });
        blocksSection.appendChild(btn);
      });
    }

    // --- Place widget using modular factory ---
    function placeWidgetByType(cell, type, params) {
      const widgetDef = WidgetRegistry.get(type);
      if (!widgetDef) return;
      const [colSpan, rowSpan] = widgetDef.getSize(params);
      if (!canPlaceWidget(cell, colSpan, rowSpan)) {
        alert("Widget doesn't fit in this location!");
        return;
      }
      // Pass grid utilities to widget factory
      const widget = widgetDef.create({
        ...params,
        isEditMode: () => isEditMode,
        onRemove: (cellArg) => removeWidget(cellArg || widget.parentNode),
        onDragStart: (w) => { draggedWidget = w; draggedCell = w.parentNode; },
        onDragEnd: handleWidgetDragEnd,
      });
      placeWidget(cell, widget, colSpan, rowSpan);
    }

    // Handle widget drag end
    function handleWidgetDragEnd() {
      if (!isEditMode) return;
      
      if (targetCell && targetCell !== draggedCell) {
        const colSpan = parseInt(draggedWidget.dataset.colSpan);
        const rowSpan = parseInt(draggedWidget.dataset.rowSpan);
        
        // Remove widget from original position
        const oldRow = parseInt(draggedCell.dataset.row);
        const oldCol = parseInt(draggedCell.dataset.col);
        
        // Clear the old cells
        for (let r = oldRow; r < oldRow + rowSpan; r++) {
          for (let c = oldCol; c < oldCol + colSpan; c++) {
            if (r === oldRow && c === oldCol) continue;
            const oldCoveredCell = document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
            if (oldCoveredCell) {
              oldCoveredCell.classList.remove('covered');
            }
          }
        }
        
        draggedCell.classList.remove('widget-cell');
        if (draggedWidget.parentNode === draggedCell) {
          draggedCell.removeChild(draggedWidget);
        }
        
        // Check if we can place in new location
        if (canPlaceWidget(targetCell, colSpan, rowSpan)) {
          placeWidget(targetCell, draggedWidget, colSpan, rowSpan);
          // Update draggedCell to new cell for future operations
          draggedCell = targetCell;
        } else {
          // Put widget back where it was
          placeWidget(draggedCell, draggedWidget, colSpan, rowSpan);
          alert("Can't move widget to this location!");
        }
      }
      
      draggedWidget = null;
      draggedCell = null;
      targetCell = null;
    }
    
    // Check if a widget can be placed
    function canPlaceWidget(cell, colSpan, rowSpan) {
      const row = parseInt(cell.dataset.row);
      const col = parseInt(cell.dataset.col);
      
      // Check if out of bounds
      if (row + rowSpan > 6 || col + colSpan > 6) {
        return false;
      }
      
      // Check if any of the cells are occupied
      for (let r = row; r < row + rowSpan; r++) {
        for (let c = col; c < col + colSpan; c++) {
          const targetCell = document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
          if (!targetCell || targetCell.classList.contains('widget-cell') || targetCell.classList.contains('covered')) {
            return false;
          }
        }
      }
      
      return true;
    }
    
    // Place a widget on the grid
    const origPlaceWidget = placeWidget;
    placeWidget = function(cell, widget, colSpan, rowSpan) {
      origPlaceWidget(cell, widget, colSpan, rowSpan);
      saveLayout();
    };

    function placeWidget(cell, widget, colSpan, rowSpan) {
      const row = parseInt(cell.dataset.row);
      const col = parseInt(cell.dataset.col);
      
      // Mark the main cell
      cell.classList.add('widget-cell');
      cell.appendChild(widget);
      
      // Set widget dimensions visually
      if (colSpan > 1 || rowSpan > 1) {
        if (colSpan > 1) {
          widget.style.width = `calc(${100 * colSpan}% + ${10 * (colSpan - 1)}px)`;
        }
        if (rowSpan > 1) {
          widget.style.height = `calc(${100 * rowSpan}% + ${10 * (rowSpan - 1)}px)`;
        }
      }
      
      // Mark covered cells
      for (let r = row; r < row + rowSpan; r++) {
        for (let c = col; c < col + colSpan; c++) {
          if (r === row && c === col) continue;
          const coverCell = document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
          if (coverCell) {
            coverCell.classList.add('covered');
          }
        }
      }
    }
    
    // Remove a widget
    const origRemoveWidget = removeWidget;
    removeWidget = function(cell) {
      origRemoveWidget(cell);
      saveLayout();
    };

    function removeWidget(cell) {
      if (!cell) return;
      const widget = cell.querySelector('.widget');
      if (!widget) return;
      let colSpan = 1, rowSpan = 1;
      const type = widget.dataset.type;
      if (type && WidgetRegistry.get(type)) {
        [colSpan, rowSpan] = WidgetRegistry.get(type).getSize(widget.dataset);
      } else if (widget.innerText) {
        const dimensions = widget.innerText.split('x');
        colSpan = parseInt(dimensions[0]);
        rowSpan = parseInt(dimensions[1]);
      }
      const row = parseInt(cell.dataset.row);
      const col = parseInt(cell.dataset.col);
      if (widget.parentNode === cell) {
        cell.removeChild(widget);
      }
      cell.classList.remove('widget-cell');
      for (let r = row; r < row + rowSpan; r++) {
        for (let c = col; c < col + colSpan; c++) {
          if (r === row && c === col) continue;
          const coverCell = document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
          if (coverCell) {
            coverCell.classList.remove('covered');
          }
        }
      }
    }

    // Load widgets dynamically
    loadWidgets();
  });